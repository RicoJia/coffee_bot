///\file
///\brief This is a node that makes the turtlebot translate 2m, in a specified direction, with a pause after every 0.2m, and the pause lasts 1/20th of a full 0.2m translation time
/// The speed control of translation is open loop control.
/// When starting, it is going to call odometer node's /set_pose to reset odometer to (0,0,0)
///\param frac_vel - fraction of the minimum translational velocity for the test. 
///\SERVICES:
/// /start - starts translation for 2 meters. True for going forwards, false for going backwards
///\PUBLISHES:
/// cmd_vel (geometry_msgs) that makes the robot make 10 translations, with extra pause time (1/20 translation time) in between.

#include "ros/ros.h"
#include "turtlesim/TeleportAbsolute.h"
#include "nuturtle_robot/Start.h"
#include <string>
#include "geometry_msgs/Twist.h"
#include "rigid2d/diff_drive.hpp"
#include <cmath>

static const int TRANSLATION_LENGTH = 2.0;

///\brief states of the state machine for rotation
enum class states{
    idle, initialize, translate, pause
};

///\brief service callback for ~start
///\params request and response messages generated by the service
///\return true for successful service call
class Translation{
public:
    Translation(){}
    Translation(ros::NodeHandle& nh, ros::NodeHandle& nh2);

    ///\brief: publish /cmd_vel at specified frequency
    void publish_cmd_vel();

private:
    ros::ServiceClient set_pose_client;
    ros::ServiceServer start_service;
    ros::Publisher cmd_vel_pub;
    double timer{0.0}, starting_time{0.0};      //QUESTION FOR MATT: IS THIS A GOOD WAY TO INITIALIZE NON-STATIC MEMBER VARIABLES??
    double translation_length{0.0};
    rigid2d::DiffDrive diff_drive;

    ///\brief: callback for start service that starts rotation
    bool start_service_callback( nuturtle_robot::Start::Request& req, nuturtle_robot::Start::Response& );
//    bool start_service_callback( nuturtle_robot::Start::Request& req, nuturtle_robot::Start::Response& res);
    double frac_vel;
    double max_trans_vel;
    double trans_vel, length_time;
    states state{states::idle};
};

Translation::Translation(ros::NodeHandle& nh, ros::NodeHandle& nh2): diff_drive() {

    nh2.getParam("frac_vel",frac_vel);
    nh2.getParam("max_trans_vel", max_trans_vel);
    
    length_time = TRANSLATION_LENGTH * 0.1/(frac_vel * max_trans_vel);
    trans_vel = 0.0;

    set_pose_client = nh.serviceClient<turtlesim::TeleportAbsolute>("/Odometer/set_pose");
    if (ros::service::waitForService("/Odometer/set_pose", 10)) {
        ROS_INFO("/Odometer/set_pose was found successfully!");
        turtlesim::TeleportAbsolute srv;
        srv.request.theta = 0.0;
        srv.request.x = 0.0;
        srv.request.y = 0.0;
        if (set_pose_client.call(srv)) {
            ROS_INFO("Odometer Pose has been reset successfully!");
        }
        else {
            ROS_WARN("WARNING: Odometer Pose failed to be reset!");
        }
    }
    else {
        std::string reason = "/Odometer/set_pose wasn't found!";
        ROS_WARN("WARNING: Shutdown request received. Reason: [%s]", reason.c_str());
    }

    start_service = nh2.advertiseService("start", &Translation::start_service_callback, this);  // this is a private service
    cmd_vel_pub = nh.advertise<geometry_msgs::Twist>("cmd_vel", 10);
}

bool Translation::start_service_callback(nuturtle_robot::Start::Request& req, nuturtle_robot::Start::Response& ){

//bool Translation::start_service_callback(nuturtle_robot::Start::Request& req, nuturtle_robot::Start::Response& res){
    double translation_sign = (req.ccw_or_forward == true)? 1.0:-1.0;
    trans_vel = translation_sign* frac_vel * max_trans_vel;
    state = states::initialize;
    return true;
}

void Translation::publish_cmd_vel() {

    switch (state){
        case states::idle:
        {
            geometry_msgs::Twist cmd_vel;
            cmd_vel_pub.publish(cmd_vel);
            break;
        };
        case states::initialize:
        {
            geometry_msgs::Twist cmd_vel;
            cmd_vel.linear.x = trans_vel;
            cmd_vel_pub.publish(cmd_vel);

            timer = ros::Time::now().toSec();
            starting_time = timer;

            state = states::translate;
            translation_length = 0;
            break;
        };
        case states::translate:
        {
            //updating current position and time, and translation_length
            auto delta_t = ros::Time::now().toSec() - timer;
            double length_increment = trans_vel * delta_t;
            translation_length += length_increment;
            diff_drive.feedforward(rigid2d::Twist2D(0.0, length_increment, 0.0));
            timer = ros::Time::now().toSec();

            //if the robot has travelled by 1m laps
            if (abs(translation_length) >= ::TRANSLATION_LENGTH){
                geometry_msgs::Twist cmd_vel;
                cmd_vel_pub.publish(cmd_vel);
                state = states::idle;
            }

            // if timer is beeping at the end of one session
            else if ((timer - starting_time) > length_time){
                geometry_msgs::Twist cmd_vel;
                cmd_vel_pub.publish(cmd_vel);
                state = states::pause;
            }

            // we haven't finished a lap yet
            else{
                geometry_msgs::Twist cmd_vel;
                cmd_vel.linear.x = trans_vel;
                cmd_vel_pub.publish(cmd_vel);

            }

            timer = ros::Time::now().toSec();
            break;
        };

        case states::pause:
        {
            geometry_msgs::Twist cmd_vel;
            cmd_vel_pub.publish(cmd_vel);
            double pause_time = (0.1 * TRANSLATION_LENGTH)/ (frac_vel * max_trans_vel)/ 20.0;
            if (ros::Time::now().toSec() - timer > pause_time){
                state = states::translate;
                double trans_vel = frac_vel * max_trans_vel;
                geometry_msgs::Twist cmd_vel;
                cmd_vel.linear.x = trans_vel;
                cmd_vel_pub.publish(cmd_vel);
                timer = ros::Time::now().toSec();
                starting_time = timer;
            }
        };
    }
}

int main (int argc, char** argv){
    ros::init(argc, argv, "translation");
    ros::NodeHandle nh;
    ros::NodeHandle nh2("~");
    Translation translation(nh, nh2);
    int frequency;
    nh2.getParam("translation_pub_frequency", frequency);
    auto r = ros::Rate(frequency);
    while(ros::ok()){
        translation.publish_cmd_vel();
        ros::spinOnce();
        r.sleep();
    }
    return 0;
}